/* Consider the following assembly code: */

/* movl 8(%ebp), %esi */
/* movl 12(%ebp), %ebx */
/* movl $-1, %edi */
/* movl $1, %edx */
/* .L2: */
/* movl %edx, %eax */
/* andl %esi, %eax */
/* xorl %eax, %edi */
/* movl %ebx, %ecx */
/* sall %cl, %edx */
/* testl %edx, %edx */
/* jne .L2 */
/* movl %edi, %eax */

/* The preceding code was generated by compiling C code that had the following */
/* overall form: */
/* int loop(int x, int n) */
/* { */
/*     int result = */
/*         int mask; */
/*     for (mask = */
/*              result ^= */
/*              } */
/*     return result; */
/* } */

/* Your task is to fill in the missing parts of the C code to get a program equivalent */
/* to the generated assembly code. Recall that the result of the function is returned */
/* in register %eax. You will find it helpful to examine the assembly code before, */
/* during, and after the loop to form a consistent mapping between the registers and */
/* the program variables. */
/* A. Which registers hold program values x, n, result, and mask? */
/* B. What are the initial values of result and mask? */
/* C. What is the test condition for mask? */
/* D. How does mask get updated? */
/* E. How does result get updated? */
/* F. Fill in all the missing parts of the C code. */

//////////////////////////////////////////////////////////////
/* A. 
x: %esi, n: %ebx, result: %eax(%edi), mask: %edx */

/* B. 
result = -1, mask = 1 */

/* C.
mask != 0 */

/* D. 
mask <<= n */

/* E. 
result ^= x & mask */

/* F.  */
int loop(int x, int n) {
    int result = -1;
    int mask;
    for (mask = 1; mask != 0; mask = mask << n) {
        result ^= x & mask;
    }

    return result;
}
