/* The code generated by the C compiler for var_prod_ele (Figure 3.29) cannot fit */
/* all of the values it uses in the loop in registers, and so it must retrieve the value of */
/* n from memory on each iteration. Write C code for this function that incorporates */
/* optimizations similar to those performed by gcc, but such that the compiled code */
/* does not spill any loop values into memory. */
/* Recall that the processor only has six registers available to hold temporary */
/* data, since registers %ebp and %esp cannot be used for this purpose. One of these */
/* registers must be used to hold the result of the multiply instruction. Hence, you */
/* must reduce the number of values in the loop from six (result, Arow, Bcol, j, n, */
/* and 4*n) to five. */
/* You will need to find a strategy that works for your particular compiler. Keep */
/* trying different strategies until you find one that works. */

int var_prod_ele(int n, int A[n][n], int B[n][n], int i, int k) {
    int j;
    int result = 0;
    
    for (j = 0; j < n; j++)
        result += A[i][j] * B[j][k];

    return result;
}

// Use my GCC, this uses %ebp as the sixth register, and it fits.

// To optimize, we can combine n and 4*n into one register
// But I think the resulted code is ugly
int var_prod_ele2(int n, int A[n][n], int B[n][n], int i, int k) {
    int j;
    int result = 0;
    
    int n4 = 4 * n;
    char *pa = (char *)(&A[i][0]);
    char *pb = (char *)(&B[0][k]);

    for (j = 0; j < n4; j += 4, pb += n4)
        result += *(int *)(pa + j) + *(int *)pb;

    return result;
}

int var_prod_ele3(int n, int A[n][n], int B[n][n], int i, int k) {
    int result = 0;
    
    int n4 = 4 * n;
    char *pa = (char *)(&A[i][0]);
    char *pb = (char *)(&B[0][k]);
    char *pend = pa + n4;


    for (; pa < pend; pa += 4, pb += n4)
        result += *(int *)pa + *(int *)pb;

    return result;
}
